<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wasm libwebp WebP Lossy 一括圧縮（Squoosh風 Compare + Zoom）</title>

  <style>
    :root{
      --bg:#0b0c10; --fg:#e8eaed; --muted:#aeb4bd; --panel:#12141a;
      --line:#2a2f3a; --accent:#7aa2ff; --danger:#ff6b6b; --ok:#66e3a2;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif;
    }
    [data-theme="FREE"]{
      --bg:#f6f7fb; --fg:#111318; --muted:#5a6473; --panel:#ffffff;
      --line:#e5e8ef; --accent:#2b6cff; --danger:#d43c3c; --ok:#0f9d58;
      --shadow: 0 10px 30px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:var(--sans);background:var(--bg);color:var(--fg);}

    header{
      position:sticky; top:0; z-index:10;
      backdrop-filter:saturate(140%) blur(10px);
      background:linear-gradient(to bottom, rgba(0,0,0,.22), rgba(0,0,0,0));
      border-bottom:1px solid color-mix(in srgb, var(--line) 60%, transparent);
    }
    [data-theme="FREE"] header{
      background:linear-gradient(to bottom, rgba(255,255,255,.85), rgba(255,255,255,.6));
    }

    .wrap{max-width:1180px;margin:0 auto;padding:18px 18px 26px;}
    .title-row{display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap}
    h1{font-size:18px;margin:0;letter-spacing:.2px}
    .subtitle{margin:6px 0 0;color:var(--muted);font-size:12px;line-height:1.4}

    .controls{
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      padding:10px;border:1px solid var(--line);background:var(--panel);
      border-radius:var(--radius);box-shadow:var(--shadow);
    }
    .control{display:flex;gap:8px;align-items:center}
    label{font-size:12px;color:var(--muted)}
    input[type="range"]{width:220px}
    input[type="file"]{display:none}

    .btn{
      appearance:none;border:1px solid var(--line);background:transparent;color:var(--fg);
      padding:9px 12px;border-radius:12px;cursor:pointer;font-size:12px;
      display:inline-flex;gap:8px;align-items:center;
      transition:transform .05s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    .btn:hover{background:color-mix(in srgb, var(--panel) 65%, transparent);border-color:color-mix(in srgb, var(--accent) 30%, var(--line))}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:color-mix(in srgb, var(--accent) 18%, var(--panel));border-color:color-mix(in srgb, var(--accent) 40%, var(--line))}
    .btn.danger{border-color:color-mix(in srgb, var(--danger) 55%, var(--line))}
    .btn:disabled{opacity:.55;cursor:not-allowed}

    .pill{
      font-family:var(--mono);font-size:11px;color:var(--muted);
      padding:6px 8px;border:1px solid var(--line);border-radius:999px;
    }
    .pill.ok{border-color:color-mix(in srgb, var(--ok) 55%, var(--line));color:color-mix(in srgb, var(--ok) 80%, var(--fg))}
    .pill.bad{border-color:color-mix(in srgb, var(--danger) 55%, var(--line));color:color-mix(in srgb, var(--danger) 80%, var(--fg))}

    .grid{display:grid;gap:14px;grid-template-columns:1.25fr .75fr;margin-top:14px}
    @media (max-width: 980px){.grid{grid-template-columns:1fr}}

    .card{border:1px solid var(--line);background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;}
    .card-h{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px 14px;border-bottom:1px solid var(--line);}
    .card-h strong{font-size:13px}
    .card-b{padding:14px}

    .drop{
      border:2px dashed color-mix(in srgb, var(--line) 80%, var(--muted));
      border-radius:16px;padding:18px;
      background:linear-gradient(180deg, color-mix(in srgb, var(--panel) 80%, transparent), transparent);
      display:flex;flex-direction:column;gap:10px;align-items:center;justify-content:center;
      min-height:140px;
    }
    .drop.drag{border-color:color-mix(in srgb, var(--accent) 65%, var(--line));background:color-mix(in srgb, var(--accent) 10%, var(--panel))}
    .drop .big{font-size:13px}
    .drop .small{font-size:12px;color:var(--muted);text-align:center;line-height:1.5}

    .stats{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .stat{border:1px solid var(--line);border-radius:14px;padding:10px 12px;background:color-mix(in srgb, var(--panel) 85%, transparent);}
    .stat .k{font-size:11px;color:var(--muted)}
    .stat .v{font-family:var(--mono);font-size:15px;margin-top:6px}
    .v.ok{color:var(--ok)} .v.bad{color:var(--danger)}

    .list{display:flex;flex-direction:column;gap:10px}
    .item{border:1px solid var(--line);border-radius:14px;overflow:hidden;background:color-mix(in srgb, var(--panel) 92%, transparent);}
    .item-h{
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      padding:10px 12px;border-bottom:1px solid var(--line);
    }
    .name{font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:52ch}
    .meta{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    .tag{
      font-family:var(--mono);font-size:11px;color:var(--muted);
      padding:4px 7px;border:1px solid var(--line);border-radius:999px;
    }
    .tag.ok{border-color:color-mix(in srgb, var(--ok) 55%, var(--line));color:color-mix(in srgb, var(--ok) 80%, var(--fg))}
    .tag.bad{border-color:color-mix(in srgb, var(--danger) 55%, var(--line));color:color-mix(in srgb, var(--danger) 80%, var(--fg))}
    .item-b{padding:12px;background:#fff;}

    .errline{
      margin-top:8px;
      font-size:11px;
      line-height:1.45;
      color:#7f1d1d;
      background:#fff1f2;
      border:1px solid #fecdd3;
      border-radius:12px;
      padding:8px 10px;
      display:none;
      white-space:pre-wrap;
    }
    .errline.show{display:block}

    /* ===== Squoosh風 Compare Viewer ===== */
    .viewer{
      position:relative;
      border:1px solid rgba(0,0,0,.12);
      border-radius:12px;
      overflow:hidden;
      background:#fff;
      height:420px;
      user-select:none;
      touch-action:none;
    }
    .viewer .stage{position:absolute; inset:0; overflow:hidden; background:#fff;}
    .viewer .layer{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      transform-origin: 0 0;
      will-change: transform;
    }
    .viewer img{
      max-width:none;
      pointer-events:none;
      -webkit-user-drag:none;
      user-select:none;
    }
    .viewer .afterClip{position:absolute; inset:0; overflow:hidden; pointer-events:none;}
    .viewer .divider{position:absolute; top:0; bottom:0; width:2px; background:rgba(0,0,0,.45); left:50%; pointer-events:none;}
    .viewer .knob{
      position:absolute; left:calc(50% - 16px); top:calc(50% - 16px);
      width:32px;height:32px;border-radius:999px; background:rgba(0,0,0,.85);
      display:flex;align-items:center;justify-content:center;
      box-shadow:0 8px 20px rgba(0,0,0,.25);
      pointer-events:none;
    }
    .viewer .knob:before{content:"◀ ▶"; font-size:11px; color:#fff; letter-spacing:1px; font-family:var(--mono);}
    .viewer .hud{
      position:absolute; left:10px; top:10px;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      padding:8px 10px;
      background:rgba(255,255,255,.86);
      border:1px solid rgba(0,0,0,.10);
      border-radius:12px;
      backdrop-filter: blur(6px);
      font-size:11px;
      color:#111;
    }
    .viewer .hud .mono{font-family:var(--mono)}
    .viewer .hud button{
      border:1px solid rgba(0,0,0,.15);
      background:transparent;
      border-radius:10px;
      padding:6px 8px;
      cursor:pointer;
      font-size:11px;
    }
    .viewer .hud button:hover{background:rgba(0,0,0,.04)}
    .viewer .hint{
      position:absolute; right:10px; bottom:10px;
      padding:6px 8px;
      font-size:11px;
      color:#111;
      background:rgba(255,255,255,.80);
      border:1px solid rgba(0,0,0,.10);
      border-radius:12px;
      backdrop-filter: blur(6px);
    }

    /* Modal */
    .modal{
      position:fixed; inset:0; z-index:100;
      display:none;
      background:rgba(0,0,0,.55);
      align-items:center; justify-content:center;
      padding:18px;
    }
    .modal.open{display:flex}
    .modal .box{
      width:min(1200px, 100%);
      height:min(820px, 92vh);
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      box-shadow:0 18px 50px rgba(0,0,0,.35);
      display:flex; flex-direction:column;
    }
    .modal .mh{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
    }
    .modal .mh .t{font-size:12px;color:var(--muted);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:75ch}
    .modal .mb{padding:12px; background:#fff; flex:1;}

    .toast{
      position:fixed; left:14px; bottom:14px; z-index:200;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:color-mix(in srgb, var(--panel) 92%, transparent);
      box-shadow:var(--shadow);
      max-width:min(720px, calc(100vw - 28px));
      font-size:12px;
      line-height:1.55;
      display:none;
    }
    .toast.show{display:block}
    .toast .t{font-family:var(--mono);font-size:11px;color:var(--muted)}
    .toast .m{margin-top:6px}
  </style>
</head>

<body data-theme="STUDIO">
<header>
  <div class="wrap">
    <div class="title-row">
      <div>
        <h1>Wasm版 libwebp：真のWebP Lossy（Squoosh風 Compare + Zoom）</h1>
        <p class="subtitle">Canvas.toBlob は使わない。Worker+WasmでWebP生成。比較は拡大/移動/スライダー。</p>
      </div>

      <div class="controls">
        <div class="control">
          <label for="quality">Quality</label>
          <input id="quality" type="range" min="0" max="100" step="1" />
          <span class="pill" id="qualityVal">80</span>
        </div>

        <div class="control">
          <label for="minReduce">最低削減率</label>
          <input id="minReduce" type="range" min="10" max="70" step="1" />
          <span class="pill" id="minReduceVal">10%</span>
        </div>

        <button class="btn primary" id="pickBtn">画像を追加</button>
        <input id="fileInput" type="file" accept="image/*" multiple />

        <button class="btn" id="startBtn">圧縮開始</button>
        <button class="btn danger" id="clearBtn">全クリア</button>

        <div class="control">
          <label>Theme</label>
          <button class="btn" id="themeBtn">STUDIO</button>
        </div>

        <span class="pill" id="workerInfo">workers: ?</span>
        <span class="pill" id="engineInfo">engine: checking…</span>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <section class="card">
      <div class="card-h">
        <strong>キュー / 比較プレビュー</strong>
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
          <span class="pill" id="queueInfo">0 files</span>
          <span class="pill" id="busyInfo">idle</span>
        </div>
      </div>

      <div class="card-b">
        <div id="drop" class="drop" tabindex="0">
          <div class="big">ここに画像をドロップ（または「画像を追加」）</div>
          <div class="small">
            操作：ホイール=ズーム / ドラッグ=移動 / スライダー=比較 / ダブルクリック=フィット
          </div>
        </div>

        <div style="height:12px"></div>
        <div class="list" id="list"></div>
      </div>
    </section>

    <aside class="card">
      <div class="card-h">
        <strong>集計</strong>
        <span class="pill">libwebp (Wasm)</span>
      </div>
      <div class="card-b">
        <div class="stats">
          <div class="stat">
            <div class="k">合計（Before）</div>
            <div class="v" id="sumBefore">0 KB</div>
          </div>
          <div class="stat">
            <div class="k">合計（After）</div>
            <div class="v" id="sumAfter">0 KB</div>
          </div>
          <div class="stat">
            <div class="k">合計削減率</div>
            <div class="v" id="sumReduce">—</div>
          </div>
          <div class="stat">
            <div class="k">進捗</div>
            <div class="v" id="progress">0/0</div>
          </div>
        </div>
      </div>
    </aside>
  </div>
</main>

<div class="modal" id="modal">
  <div class="box">
    <div class="mh">
      <div class="t" id="modalTitle">—</div>
      <div style="display:flex;gap:8px;align-items:center;">
        <span class="pill" id="modalMeta">—</span>
        <button class="btn danger" id="modalClose">閉じる</button>
      </div>
    </div>
    <div class="mb" id="modalBody"></div>
  </div>
</div>

<div class="toast" id="toast">
  <div class="t" id="toastTitle">—</div>
  <div class="m" id="toastMsg">—</div>
</div>

<script type="module">
  const LS = {
    quality: 'wasmwebp_quality_full',
    minReduce: 'wasmwebp_minReduce_full',
    theme: 'wasmwebp_theme_full',
  };

  const $ = (sel) => document.querySelector(sel);

  const qualityEl = $('#quality');
  const qualityValEl = $('#qualityVal');
  const minReduceEl = $('#minReduce');
  const minReduceValEl = $('#minReduceVal');

  const pickBtn = $('#pickBtn');
  const fileInput = $('#fileInput');
  const startBtn = $('#startBtn');
  const clearBtn = $('#clearBtn');
  const themeBtn = $('#themeBtn');

  const drop = $('#drop');
  const list = $('#list');

  const queueInfo = $('#queueInfo');
  const busyInfo = $('#busyInfo');
  const workerInfo = $('#workerInfo');
  const engineInfo = $('#engineInfo');

  const sumBeforeEl = $('#sumBefore');
  const sumAfterEl = $('#sumAfter');
  const sumReduceEl = $('#sumReduce');
  const progressEl = $('#progress');

  const modal = $('#modal');
  const modalTitle = $('#modalTitle');
  const modalMeta = $('#modalMeta');
  const modalBody = $('#modalBody');
  const modalClose = $('#modalClose');

  const toast = $('#toast');
  const toastTitle = $('#toastTitle');
  const toastMsg = $('#toastMsg');

  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const loadNum = (k, def) => {
    const v = Number(localStorage.getItem(k));
    return Number.isFinite(v) ? v : def;
  };
  const loadStr = (k, def) => localStorage.getItem(k) ?? def;

  const state = {
    queue: [],
    running: false,
    done: 0,
    workers: [],
    nextWorker: 0,
    jobs: new Map(),
    engineReady: false,
    engineErr: '',
  };

  function bytesToKB(bytes){ return Math.round((bytes / 1024) * 10) / 10; }
  function pct(n){ return Math.round(n * 10) / 10; }
  function escapeHtml(s){
    return String(s)
      .replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
      .replaceAll('"','&quot;').replaceAll("'","&#39;");
  }

  function showToast(title, msg, ms=12000){
    toastTitle.textContent = title;
    toastMsg.textContent = msg;
    toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.classList.remove('show'), ms);
  }

  function setTheme(theme){
    document.body.setAttribute('data-theme', theme);
    themeBtn.textContent = theme;
    localStorage.setItem(LS.theme, theme);
  }
  function setQuality(q){
    q = clamp(Math.round(q), 0, 100);
    qualityEl.value = String(q);
    qualityValEl.textContent = String(q);
    localStorage.setItem(LS.quality, String(q));
  }
  function setMinReduce(p){
    p = clamp(Math.round(p), 10, 70);
    minReduceEl.value = String(p);
    minReduceValEl.textContent = `${p}%`;
    localStorage.setItem(LS.minReduce, String(p));
  }
  function setBusy(isBusy){ busyInfo.textContent = isBusy ? 'busy' : 'idle'; }

  // ========= Worker Source（esm.sh bundle + Skypackフォールバックで裸import根絶） =========
  const workerSource = `
    let _encode = null;
    let _inited = false;

    async function importModuleWithFallback(urls){
      let lastErr = null;
      for (const u of urls){
        try{
          return await import(u);
        }catch(e){
          lastErr = e;
        }
      }
      throw lastErr || new Error("import failed");
    }

    async function loadEncoder() {
      if (_encode && _inited) return _encode;

      // ★ここが肝：bundleで裸import（wasm-feature-detect等）を解決してしまう
      // esm.sh が塞がれてる環境用に skypack をフォールバック
      const MOD_URLS = [
        "https://esm.sh/@jsquash/webp@1.5.0/encode.js?bundle&target=es2020&no-dts",
        "https://cdn.skypack.dev/@jsquash/webp@1.5.0/encode.js"
      ];

      const WASM_SIMD_URL = "https://cdn.jsdelivr.net/npm/@jsquash/webp@1.5.0/codec/enc/webp_enc_simd.wasm";
      const WASM_URL      = "https://cdn.jsdelivr.net/npm/@jsquash/webp@1.5.0/codec/enc/webp_enc.wasm";

      const mod = await importModuleWithFallback(MOD_URLS);

      const encode = mod.default;
      const init = mod.init;

      if (typeof encode !== "function" || typeof init !== "function") {
        throw new Error("Unexpected @jsquash/webp module shape (encode/init not found)");
      }

      async function fetchAB(url) {
        const res = await fetch(url, { cache: "force-cache" });
        if (!res.ok) throw new Error(\`WASM fetch failed: \${res.status} \${url}\`);
        return await res.arrayBuffer();
      }

      try {
        const wasm = await fetchAB(WASM_SIMD_URL);
        await init(wasm);
      } catch (e) {
        const wasm = await fetchAB(WASM_URL);
        await init(wasm);
      }

      _encode = encode;
      _inited = true;
      return _encode;
    }

    async function decodeToImageData(arrayBuffer){
      const blob = new Blob([arrayBuffer]);

      if (typeof createImageBitmap === "function"){
        const bmp = await createImageBitmap(blob);
        const canvas = new OffscreenCanvas(bmp.width, bmp.height);
        const ctx = canvas.getContext("2d", { willReadFrequently: true, alpha: true });
        ctx.clearRect(0,0,bmp.width,bmp.height);
        ctx.drawImage(bmp, 0, 0);
        const imageData = ctx.getImageData(0,0,bmp.width,bmp.height);
        bmp.close?.();
        return imageData;
      }

      if (typeof ImageDecoder === "function"){
        const decoder = new ImageDecoder({ data: blob, type: blob.type });
        const frame = await decoder.decode({ frameIndex: 0 });
        const { image } = frame;
        const w = image.displayWidth;
        const h = image.displayHeight;
        const canvas = new OffscreenCanvas(w, h);
        const ctx = canvas.getContext("2d", { willReadFrequently: true, alpha: true });
        ctx.drawImage(image, 0, 0);
        const imageData = ctx.getImageData(0,0,w,h);
        image.close();
        decoder.close();
        return imageData;
      }

      throw new Error("No decode method in Worker (createImageBitmap / ImageDecoder unavailable)");
    }

    async function encodeWithFloor(imageData, targetQuality, minReducePct, beforeBytes){
      const enc = await loadEncoder();

      let q0 = Math.max(0, Math.min(100, Math.round(targetQuality)));
      let minR = Math.max(0, Math.min(99, Math.round(minReducePct)));

      let best = null;
      const tried = new Set();

      const plan = [];
      plan.push(q0);
      for (let q = q0 - 5; q >= 0; q -= (q > 40 ? 10 : (q > 20 ? 5 : 2))) plan.push(q);
      plan.push(0);

      for (const qq0 of plan){
        const qq = Math.max(0, Math.min(100, Math.round(qq0)));
        if (tried.has(qq)) continue;
        tried.add(qq);

        const buf = await enc(imageData, { quality: qq });
        const afterBytes = buf.byteLength;
        const reduction = beforeBytes > 0 ? (1 - (afterBytes / beforeBytes)) * 100 : 0;

        if (!best || afterBytes < best.afterBytes){
          best = { buf, q: qq, afterBytes, reduction };
        }
        if (reduction >= minR){
          return { ok: true, ...best };
        }
      }
      return { ok: false, ...best };
    }

    self.onmessage = async (e) => {
      const { jobId, type } = e.data || {};

      if (type === "PING"){
        try{
          await loadEncoder();
          self.postMessage({ jobId, ok:true, type:"PONG" });
        }catch(err){
          self.postMessage({ jobId, ok:false, type:"PONG", error:String(err?.message || err) });
        }
        return;
      }

      const { arrayBuffer, quality, minReducePct, beforeBytes } = e.data;

      try{
        const imageData = await decodeToImageData(arrayBuffer);
        const res = await encodeWithFloor(imageData, quality, minReducePct, beforeBytes);

        self.postMessage({
          jobId,
          ok: res.ok,
          webpBuffer: res.buf,
          afterBytes: res.afterBytes,
          qualityUsed: res.q,
          reduction: res.reduction
        }, [res.buf]);
      }catch(err){
        self.postMessage({ jobId, ok:false, error:String(err?.message || err) });
      }
    };
  `;

  function createWorker(){
    const blob = new Blob([workerSource], { type: 'text/javascript' });
    const url = URL.createObjectURL(blob);
    const w = new Worker(url, { type: 'module' });
    URL.revokeObjectURL(url);

    w.onerror = (e) => {
      state.engineReady = false;
      state.engineErr = `Worker error: ${e.message || e.type || 'unknown'} (line:${e.lineno || '?'})`;
      engineInfo.textContent = 'engine: ERROR';
      engineInfo.className = 'pill bad';
      showToast('Worker起動失敗', state.engineErr);
    };

    w.onmessage = (e) => {
      const msg = e.data;
      const resolver = state.jobs.get(msg.jobId);
      if (resolver) { state.jobs.delete(msg.jobId); resolver(msg); }
    };
    return w;
  }

  function initWorkers(){
    const hc = navigator.hardwareConcurrency || 4;
    const n = clamp(hc - 1, 2, 8);
    state.workers.forEach(w => w.terminate());
    state.workers = Array.from({length:n}, () => createWorker());
    state.nextWorker = 0;
    workerInfo.textContent = `workers: ${n}`;
  }
  function nextWorker(){
    const w = state.workers[state.nextWorker % state.workers.length];
    state.nextWorker++;
    return w;
  }
  function callWorker(payload){
    const jobId = crypto.randomUUID();
    const w = nextWorker();
    const p = new Promise((resolve) => state.jobs.set(jobId, resolve));
    w.postMessage({ jobId, ...payload }, payload.arrayBuffer ? [payload.arrayBuffer] : []);
    return p;
  }

  async function checkEngine(){
    try{
      const res = await callWorker({ type:"PING" });
      if (res.ok){
        state.engineReady = true;
        state.engineErr = '';
        engineInfo.textContent = 'engine: READY';
        engineInfo.className = 'pill ok';
      }else{
        state.engineReady = false;
        state.engineErr = res.error || 'unknown';
        engineInfo.textContent = 'engine: ERROR';
        engineInfo.className = 'pill bad';
        showToast('libwebp(Wasm)起動失敗', state.engineErr);
      }
    }catch(err){
      state.engineReady = false;
      state.engineErr = String(err?.message || err);
      engineInfo.textContent = 'engine: ERROR';
      engineInfo.className = 'pill bad';
      showToast('libwebp(Wasm)起動失敗', state.engineErr);
    }
  }

  // ===== Compare Viewer =====
  function createCompareViewer({beforeUrl, afterUrl, beforeBytes, afterBytes, reduction, qualityUsed, fileName}){
    const wrap = document.createElement('div');
    wrap.className = 'viewer';
    wrap.tabIndex = 0;

    wrap.innerHTML = `
      <div class="stage">
        <div class="layer before"><img alt="before"></div>
        <div class="afterClip">
          <div class="layer after"><img alt="after"></div>
        </div>
        <div class="divider"></div>
        <div class="knob"></div>
      </div>

      <div class="hud">
        <span><b>Before</b> <span class="mono" data-b>${bytesToKB(beforeBytes)} KB</span></span>
        <span>→</span>
        <span><b>After</b> <span class="mono" data-a>${afterBytes != null ? bytesToKB(afterBytes) : '—'} KB</span></span>
        <span class="mono">|</span>
        <span><b>削減</b> <span class="mono" data-r>${reduction != null ? pct(reduction)+'%' : '—'}</span></span>
        <span class="mono">|</span>
        <span><b>q</b> <span class="mono" data-q>${qualityUsed != null ? qualityUsed : '—'}</span></span>
        <button type="button" data-zoomout>-</button>
        <button type="button" data-zoomin>+</button>
        <button type="button" data-reset>fit</button>
        <button type="button" data-full>拡大表示</button>
      </div>

      <div class="hint">ホイール=ズーム / ドラッグ=移動 / スライダー=比較</div>
    `;

    const imgB = wrap.querySelector('.before img');
    const imgA = wrap.querySelector('.after img');
    const clip = wrap.querySelector('.afterClip');
    const divider = wrap.querySelector('.divider');
    const knob = wrap.querySelector('.knob');

    imgB.src = beforeUrl;
    imgA.src = afterUrl || '';

    let split = 0.5;
    const applySplit = () => {
      const w = wrap.clientWidth;
      const x = Math.round(w * split);
      clip.style.clipPath = `inset(0 0 0 ${x}px)`;
      divider.style.left = `${x}px`;
      knob.style.left = `${x - 16}px`;
    };

    let scale = 1;
    let tx = 0;
    let ty = 0;
    let naturalW = 0;
    let naturalH = 0;

    const beforeLayer = wrap.querySelector('.layer.before');
    const afterLayer = wrap.querySelector('.layer.after');

    const applyTransform = () => {
      const t = `translate(${tx}px, ${ty}px) scale(${scale})`;
      beforeLayer.style.transform = t;
      afterLayer.style.transform = t;
    };

    const fitToView = () => {
      if (!naturalW || !naturalH) return;
      const vw = wrap.clientWidth;
      const vh = wrap.clientHeight;
      const sx = vw / naturalW;
      const sy = vh / naturalH;
      scale = Math.min(sx, sy);
      tx = Math.round((vw - naturalW * scale) / 2);
      ty = Math.round((vh - naturalH * scale) / 2);
      applyTransform();
      applySplit();
    };

    const onImgLoad = () => {
      naturalW = imgB.naturalWidth || naturalW;
      naturalH = imgB.naturalHeight || naturalH;
      fitToView();
    };
    if (imgB.complete) onImgLoad(); else imgB.addEventListener('load', onImgLoad);

    let dragging = false;
    let dragMode = null;
    let lastX = 0, lastY = 0;

    const hitSplit = (clientX) => {
      const r = wrap.getBoundingClientRect();
      const x = clientX - r.left;
      const splitX = wrap.clientWidth * split;
      return Math.abs(x - splitX) <= 18;
    };

    wrap.addEventListener('pointerdown', (e) => {
      wrap.setPointerCapture(e.pointerId);
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      dragMode = hitSplit(e.clientX) ? 'split' : 'pan';
    });

    wrap.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      if (dragMode === 'pan'){
        tx += dx; ty += dy;
        applyTransform();
      } else {
        const r = wrap.getBoundingClientRect();
        const x = clamp(e.clientX - r.left, 0, wrap.clientWidth);
        split = x / wrap.clientWidth;
        applySplit();
      }
    });

    const endDrag = (e) => {
      if (!dragging) return;
      dragging = false;
      dragMode = null;
      try{ wrap.releasePointerCapture(e.pointerId); }catch{}
    };
    wrap.addEventListener('pointerup', endDrag);
    wrap.addEventListener('pointercancel', endDrag);

    wrap.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = wrap.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;

      const prevScale = scale;
      const delta = -e.deltaY;
      const factor = delta > 0 ? 1.08 : 0.92;
      scale = clamp(scale * factor, 0.05, 30);

      tx = cx - (cx - tx) * (scale / prevScale);
      ty = cy - (cy - ty) * (scale / prevScale);
      applyTransform();
    }, { passive:false });

    wrap.addEventListener('dblclick', () => fitToView());

    wrap.querySelector('[data-zoomin]').addEventListener('click', () => {
      const cx = wrap.clientWidth / 2, cy = wrap.clientHeight / 2;
      const prev = scale;
      scale = clamp(scale * 1.2, 0.05, 30);
      tx = cx - (cx - tx) * (scale / prev);
      ty = cy - (cy - ty) * (scale / prev);
      applyTransform();
    });
    wrap.querySelector('[data-zoomout]').addEventListener('click', () => {
      const cx = wrap.clientWidth / 2, cy = wrap.clientHeight / 2;
      const prev = scale;
      scale = clamp(scale / 1.2, 0.05, 30);
      tx = cx - (cx - tx) * (scale / prev);
      ty = cy - (cy - ty) * (scale / prev);
      applyTransform();
    });
    wrap.querySelector('[data-reset]').addEventListener('click', () => fitToView());

    wrap.querySelector('[data-full]').addEventListener('click', () => {
      openModalCompare({ beforeUrl, afterUrl, beforeBytes, afterBytes, reduction, qualityUsed, fileName });
    });

    const ro = new ResizeObserver(() => { applySplit(); });
    ro.observe(wrap);

    return {
      el: wrap,
      update({afterUrl, afterBytes, reduction, qualityUsed}){
        if (afterUrl) imgA.src = afterUrl;
        wrap.querySelector('[data-a]').textContent = afterBytes != null ? (bytesToKB(afterBytes)+' KB') : '—';
        wrap.querySelector('[data-r]').textContent = reduction != null ? (pct(reduction)+'%') : '—';
        wrap.querySelector('[data-q]').textContent = qualityUsed != null ? String(qualityUsed) : '—';
      }
    };
  }

  function openModalCompare(data){
    modal.classList.add('open');
    modalTitle.textContent = data.fileName || 'preview';
    const b = (data.beforeBytes != null) ? `${bytesToKB(data.beforeBytes)}KB` : '—';
    const a = (data.afterBytes != null) ? `${bytesToKB(data.afterBytes)}KB` : '—';
    const r = (data.reduction != null) ? `${pct(data.reduction)}%` : '—';
    modalMeta.textContent = `before ${b} → after ${a} | reduction ${r} | q ${data.qualityUsed ?? '—'}`;

    modalBody.innerHTML = '';
    const v = createCompareViewer(data);
    modalBody.appendChild(v.el);
  }
  function closeModal(){ modal.classList.remove('open'); modalBody.innerHTML = ''; }
  modalClose.addEventListener('click', closeModal);
  modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });

  function renderTotals(){
    queueInfo.textContent = `${state.queue.length} files`;
    progressEl.textContent = `${state.done}/${state.queue.length}`;

    const sumBefore = state.queue.reduce((a, it) => a + (it.beforeBytes || 0), 0);
    const sumAfter = state.queue.reduce((a, it) => a + (it.afterBytes || 0), 0);

    sumBeforeEl.textContent = `${bytesToKB(sumBefore)} KB`;
    sumAfterEl.textContent = `${bytesToKB(sumAfter)} KB`;

    if (sumBefore > 0 && sumAfter > 0){
      const reduce = (1 - (sumAfter / sumBefore)) * 100;
      sumReduceEl.textContent = `${pct(reduce)}%`;
      sumReduceEl.className = `v ${reduce >= Number(minReduceEl.value) ? 'ok' : 'bad'}`;
    } else {
      sumReduceEl.textContent = '—';
      sumReduceEl.className = 'v';
    }
  }

  function addFiles(files){
    const arr = Array.from(files || []);
    for (const f of arr){
      if (!f.type.startsWith('image/')) continue;
      const id = crypto.randomUUID();
      const beforeUrl = URL.createObjectURL(f);

      state.queue.push({
        id,
        file: f,
        beforeUrl,
        afterUrl: '',
        beforeBytes: f.size,
        afterBytes: 0,
        reduction: null,
        qualityUsed: null,
        status: 'queued',
        error: '',
        viewer: null,
        afterBlob: null,
      });
    }
    renderList();
    renderTotals();
  }

  function clearAll(){
    for (const it of state.queue){
      try{ URL.revokeObjectURL(it.beforeUrl); }catch{}
      if (it.afterUrl) { try{ URL.revokeObjectURL(it.afterUrl); }catch{} }
    }
    state.queue = [];
    state.done = 0;
    renderList();
    renderTotals();
  }

  function removeItem(id){
    const i = state.queue.findIndex(x => x.id === id);
    if (i < 0) return;
    const it = state.queue[i];
    try{ URL.revokeObjectURL(it.beforeUrl); }catch{}
    if (it.afterUrl) { try{ URL.revokeObjectURL(it.afterUrl); }catch{} }
    state.queue.splice(i,1);
    state.done = state.queue.filter(x => x.status === 'done' || x.status === 'error').length;
    renderList();
    renderTotals();
  }

  function downloadItem(id){
    const it = state.queue.find(x => x.id === id);
    if (!it?.afterBlob) return;
    const a = document.createElement('a');
    const url = URL.createObjectURL(it.afterBlob);
    a.href = url;
    a.download = it.file.name.replace(/\.[^.]+$/, '') + `.q${it.qualityUsed ?? qualityEl.value}.webp`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 800);
  }

  function renderList(){
    list.innerHTML = '';

    for (const it of state.queue){
      const el = document.createElement('div');
      el.className = 'item';

      const beforeKb = `${bytesToKB(it.beforeBytes)} KB`;
      const afterKb = (it.afterBytes && it.afterUrl) ? `${bytesToKB(it.afterBytes)} KB` : '—';
      const red = (it.afterBytes && it.afterUrl) ? (1 - (it.afterBytes / it.beforeBytes)) * 100 : null;
      if (red != null) it.reduction = red;

      const minR = Number(minReduceEl.value);
      const okReduce = (red != null) ? (red >= minR) : false;

      const statusTag = (() => {
        if (it.status === 'queued') return `<span class="tag">queued</span>`;
        if (it.status === 'working') return `<span class="tag">working</span>`;
        if (it.status === 'done') return `<span class="tag ok">done</span>`;
        return `<span class="tag bad">error</span>`;
      })();

      const reduceTag = (red == null)
        ? `<span class="tag">reduction: —</span>`
        : `<span class="tag ${okReduce ? 'ok':'bad'}">reduction: ${pct(red)}%</span>`;

      const qTag = it.qualityUsed != null
        ? `<span class="tag">q: ${it.qualityUsed}</span>`
        : `<span class="tag">q: —</span>`;

      const dlDisabled = !it.afterBlob;

      el.innerHTML = `
        <div class="item-h">
          <div class="name" title="${escapeHtml(it.file.name)}">${escapeHtml(it.file.name)}</div>
          <div class="meta">
            ${statusTag}
            <span class="tag">before: ${beforeKb}</span>
            <span class="tag">after: ${afterKb}</span>
            ${reduceTag}
            ${qTag}
            <button class="btn" ${dlDisabled?'disabled':''} data-dl="${it.id}">WebP保存</button>
            <button class="btn danger" data-rm="${it.id}">削除</button>
          </div>
        </div>
        <div class="item-b">
          <div data-view="${it.id}"></div>
          <div class="errline ${it.error ? 'show':''}">${escapeHtml(it.error || '')}</div>
        </div>
      `;

      el.addEventListener('click', (ev) => {
        const t = ev.target;
        if (!(t instanceof HTMLElement)) return;
        const dl = t.getAttribute('data-dl');
        const rm = t.getAttribute('data-rm');
        if (dl) downloadItem(dl);
        if (rm) removeItem(rm);
      });

      const holder = el.querySelector(`[data-view="${it.id}"]`);
      const viewer = createCompareViewer({
        beforeUrl: it.beforeUrl,
        afterUrl: it.afterUrl || '',
        beforeBytes: it.beforeBytes,
        afterBytes: it.afterBytes && it.afterUrl ? it.afterBytes : null,
        reduction: it.afterBytes && it.afterUrl ? it.reduction : null,
        qualityUsed: it.qualityUsed,
        fileName: it.file.name,
      });

      it.viewer = viewer;
      holder.appendChild(viewer.el);

      list.appendChild(el);
    }
  }

  async function startCompression(){
    if (state.running) return;
    if (state.queue.length === 0) return;

    if (!state.engineReady){
      showToast('圧縮できません', 'engine: ERROR です。トーストの理由を見てください。');
      return;
    }

    state.running = true;
    setBusy(true);

    const targetQuality = Number(qualityEl.value);
    const minReducePct = Number(minReduceEl.value);

    const targets = state.queue.filter(x => x.status === 'queued' || x.status === 'error');

    const concurrency = state.workers.length;
    const pending = targets.slice();
    let active = 0;

    await new Promise((resolveAll) => {
      const pump = () => {
        while (active < concurrency && pending.length){
          const it = pending.shift();
          if (!it) break;

          active++;
          it.status = 'working';
          it.error = '';
          renderList();
          renderTotals();

          (async () => {
            try{
              const ab = await it.file.arrayBuffer();
              const msg = await callWorker({
                arrayBuffer: ab,
                quality: targetQuality,
                minReducePct,
                beforeBytes: it.beforeBytes,
              });

              if (!msg.ok){
                it.status = 'error';
                it.error = msg.error || `削減率が ${minReducePct}% を下回りました（best=${pct(msg.reduction || 0)}%）`;
              } else {
                it.status = 'done';
              }

              if (msg.webpBuffer){
                const webpBlob = new Blob([msg.webpBuffer], { type: 'image/webp' });
                it.afterBlob = webpBlob;
                it.afterBytes = msg.afterBytes || 0;
                it.qualityUsed = msg.qualityUsed ?? null;
                it.reduction = msg.reduction ?? null;

                if (it.afterUrl) { try{ URL.revokeObjectURL(it.afterUrl); }catch{} }
                it.afterUrl = URL.createObjectURL(webpBlob);

                it.viewer?.update({
                  afterUrl: it.afterUrl,
                  afterBytes: it.afterBytes,
                  reduction: it.reduction,
                  qualityUsed: it.qualityUsed
                });
              }

            }catch(err){
              it.status = 'error';
              it.error = String(err?.message || err);
            }finally{
              active--;
              state.done = state.queue.filter(x => x.status === 'done' || x.status === 'error').length;
              renderList();
              renderTotals();
              if (pending.length) pump();
              else if (active === 0) resolveAll();
            }
          })();
        }
      };
      pump();
    });

    state.running = false;
    setBusy(false);
    renderTotals();
  }

  // Events
  pickBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', () => { addFiles(fileInput.files); fileInput.value = ''; });
  startBtn.addEventListener('click', startCompression);
  clearBtn.addEventListener('click', clearAll);

  qualityEl.addEventListener('input', () => setQuality(Number(qualityEl.value)));
  minReduceEl.addEventListener('input', () => setMinReduce(Number(minReduceEl.value)));

  themeBtn.addEventListener('click', () => {
    const now = document.body.getAttribute('data-theme') || 'STUDIO';
    setTheme(now === 'STUDIO' ? 'FREE' : 'STUDIO');
  });

  const stop = (e) => { e.preventDefault(); e.stopPropagation(); };
  ['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, (e) => { stop(e); drop.classList.add('drag'); }));
  ['dragleave','drop'].forEach(ev => drop.addEventListener(ev, (e) => { stop(e); drop.classList.remove('drag'); }));
  drop.addEventListener('drop', (e) => { const dt = e.dataTransfer; if (dt) addFiles(dt.files); });

  // Init
  setTheme(loadStr(LS.theme, 'STUDIO'));
  setQuality(loadNum(LS.quality, 80));
  setMinReduce(loadNum(LS.minReduce, 10));

  initWorkers();
  renderList();
  renderTotals();
  await checkEngine();

  // cache killer notice (手動で ?v=xx を付けるのが面倒なら、このページをブックマークし直す)
  if (!location.search.includes('v=')) {
    // ここは「自動リロード」すると嫌がる人がいるので、トーストで促すだけにする
    showToast('キャッシュ対策', 'GitHub Pagesで更新が反映されない時は、URL末尾に ?v=2 などを付けて開いてください。');
  }
</script>
</body>
</html>
